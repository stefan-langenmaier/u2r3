\section{Regelumsetzung allgemein}
Regeln sind hier sogenannte Inferenzprozeduren, das sind automatisierte Verfahren zur Berechnung logischer Folgerungen. Inferenzenprozeduren sind bereits aus der Aussagenlogik bekannt.

\begin{itemize}
  \item Modus ponens
  A->B
  A
  ---
  B
  \item Modus tollens
  A->B
  ~B
  ---
  ~A
\end{itemize}

Diese beiden Ableitungsregeln erlauben es, die beiden Aussagen in der Prämisse durch die Schlussfolgerung zu ersetzen. Für einen Schlussfolgerer mit direct-materialization werden, die Prämissen nicht ersetzt sondern weiterhin erhalten. Es könnte ja möglich sein das weitere ABleitungsschritte damit möglich sind oder das spätere Anfragen auf diese Aussagen abzielen. Mit einer Ableitungsregel kann also die Aussagenbasis vergrößert werden.

Es sind dabei jedoch nicht alle Ableitungsregeln gültig.

A -> B
B
---
A

ist z.B. kein gültiger Schluss.

Eine Menge von vernünftigen Ableitungsregeln zu finden ist keine leichte Aufgabe. Dabei eine möglichst große Ausdrucksmächtigkeit zu erhalten ohne die Komplexität der Regeln aus den Augen zu verlieren wurde versucht mit OWL2 RL Fragement zu erreichen.

\subsection{Kriterien für Inferenzprozeduren}
Die Ableitungsregeln arbeiten eng mit der Wissensrepräsentation zusammen. Auch hier gibt es Kriterien für die Einordnung der Ableitungsprozedur.

\begin{itemize}
  \item Korrektheit
  Eine Inferenzprodzerdur ist korrekt, wenn für jede Ableitung einer Formel aus einer Formel Menge auch gilt, das diese Formel Modell für die Formelmenge ist.
  \item Vollständigkeit
  Eine Inferenzprozedur ist vollständig, wenn für jedes Modell einer Formelmenge auch die Inferenzprozedur die Formel ableiten kann.
  \item Entscheidbarkeit
  Eine Inferenzprozedur ist entscheidbar, wenn sie immer zu dem Ergebniss kommt (terminiert), ob die Formel aus der Formelmenge ableitbar ist oder nicht.
  \item Komplexität
  Die Komplexität bezieht sich auf die Komplexität der Inferenzprozedur, um eine Ableitung durchzuführen.
\end{itemize}


\section{Regelumsetzung von OWL2 RL}

In der Profil-Spezifikation von OWL2 RL \cite{OWL2Profiles} wird eine Reihe von Regeln angegeben, die es ermöglichen entsprechend der Sprachmächtigkeit darin zu schlussfolgern.
%\note Was ist die Sprachmächtigkeit?
%\note Was heißt schlussfolgern?
Die angegebenen Regeln sind vollständig aber nicht optimal \cite{placeholder}, d.h. mit diesem Satz an Regeln kann auf alles geschloßen werden, auf was im RL Profil geschloßen werden kann. Allerdings muss dieser Satz an Regeln der einzige oder minimale Satz sein, die zu diesem Ergebniss kommen..

In dieser Diplomarbeit wird versucht möglichst nah an diesem Menge von Regeln zu bleiben, um sichergestellt zu haben das die Semantik korrekt erhalten ist und somit die Implementierung leichter zu überprüfen ist.
Abweichungen von den vorgegebenen Regeln findet nur in besonderen Ausnahmen statt und werden später \ref{mitternachtsformel} auch einzeln begründet. Eine allgemeine Begründung für die Existenz der Ausnahmen liegt darin, dass die Regeln in SQL übersetzt werden - was schon von alleine eine andere Schreib- und Sichtweise  mitbringt - und zum anderen sind gewisse Optimierungen erwünscht.
Wieso und wie das funktioniert wird in Abschnitt \cite{placeholder} an einigen Beispielen und Sonderfällen demonstriert.

\subsection{Regeloptimierung}

Die Regelanwendungen sind der teuerste Teil im Programmablauf, darum gibt es hier verschiedene Möglichkeiten diesen Prozess zu beeinflussen und damit auf spezielle Bedürfnisse anpassen zu können.

Man kann entscheiden, ob man die Ontologie später verändern will. Das hat zur Folge, das die Entstehungsgeschichte von abgeleiteten Fakten erhalten bleiben muss.

Eine naive Anwendung der Regel hätte außerdem zur Folge, das sich die Regeln immer auf alle Fakten beziehen. Meist reicht es aber asich auf erzeugt Fakten aus vorherigen Schritten zu beziehen. Das wird näher im Abschnittt \cite{placeholder} (delta-Iteration) geklärt. Hierbei gibt es zwei verschiedene Varianten wie diese umgesetzt ist.

Die Struktur der Umsetzung der Regeln in SQL ist zwar fix aber durch gewisse Optimierungen abhängig vom Ausführungskontext. Zum einen wurden zwei verschiedene Varianten der delta-Iteration implmentiert und zum anderen müssen die Regeln, wenn ein kaskadierender Löschmodus aktiv ist auch Informationen mitführen, welche Fakten das aktuelle Faktum erzeugt haben.

\subsubsection{delta-Iteration}
\input{delta-iteration}

\subsubsection{Magic-Sets}
Auf die Implementierung von Magic-Set-Algorithmen kann verzichtet werden, da die Regel-Implementierung in SQL fast ausschließlich von Hand abliefund deswegen schon von vorneherein optimiert sind.
Referenzen-MEHR.


\subsection{Regelbeispiele}
\input{u2r3-regel-beispiele}
