\chapter{Ausblick}
\label{kapitel-ausblick}
OWL2 wurde im Laufe dieser Diplomarbeit als Recommendation veröffentlicht. Damit ist sie ein offizieller Standard des W3C. Die Anzahl der Konferenzen\footnote{\url{http://semanticweb.org/wiki/Events}}, die zum Thema \emph{Semantic Web} abgehalten werden und die Ankündigungen von Anwendungen zur Unterstützung für OWL2 versprechen eine lebhafte Zukunft. Es wurden sogar schon die Weiterentwicklung zu OWL3 \cite{Hitzler2009} angedacht.

Wie aktiv dabei das RL Fragment teilnehmen wird die Zukunft zeigen. Durch die Vielzahl an entstehenden Ontologien könnte es sich aber durch sein große Ausdrucksmächtigkeit und gutmütigen Schlussfolgerungseigenschaften anbieten. Dafür nötig sind aber gute Werkzeuge. Mit dieser Diplomarbeit soll dazu ein Stückchen beigetragen worden sein.

\section{Weitere Optimierungen}
\label{abschnitt-weitere-optimierungen}
Der Schlussfolgerer wurde immer mit dem  Hintergedanken entwickelt Parallelisierung und Approximation beim Ableiten zu ermöglichen. Im Laufe der Arbeit wurden aber noch andere Möglichkeiten zur Verbesserung gefunden, die allerdings auf Grund der begrenzten Zeit nicht oder nur unvollständig umgesetzt werden konnten.

\begin{itemize}
  \item Die SQL-Abfragen weiter optimieren. Vor allem im nicht kaskadierenden Modus können einige Abfragen mit Datenbank spezifischeren Konstrukten ersetzt werden. Das erzeugt aber mehr Fallunterscheidungen und muss einzeln geprüft werden, ob die Abweichung von der Standardumsetzung korrekt ist.
  \item Man könnte manche Regeln, insbesondere dt-eq mit anderen zusammenlegen, da wenn sie alleine laufen gelassen wird recht aufwendig ist. Hierbei könnte man sich auch gleich über einen optimaleren Satz an Regeln für das OWL2 RL Fragment Gedanken machen.
  \item Der Regelsatz könnte noch erweitert werden, wie das Beispiel in der DomusAG-Ontologie zeigt. Vor allem im Bereich der Datatype Restriction kann man noch einiges schlussfolgern.
  \item Es wäre vorstellbar eine Lösung zwischen der Abspeicherung der vollen Ableitungshierarchie und keiner Abspeicherung zu finden. Besonders bei den drei Spezialregeln ist der Aufwand hoch die Ableitungshierarchie mit abzuspeichern. Man könnte hier eine Art Wildcard benutzen. Das sähe dann folgendermaßen aus, das alle Fakten, die schon von einem Fakt mit einer Wildcard abgeleitet wurden wieder eine Wildcard bekommen. Wird dann eine Fakt gelöscht wird es und alle seine Abhängigkeiten plus alle Fakten die eine Wildcard haben gelöscht.
  \item Die Zahl der Regeln, die angewendet werden könnte man noch weiter reduzieren. Relationen wissen, ob sie Fakten enthalten oder nicht. Wenn eine Regel ausgelöst werden soll die auf einer Relation arbeitet die keine Fakten enthält könnte sie schon vorher abgebrochen werden.
  \item Im Moment sind die Literale über verschiedene Relationen verteilt. Würde man diese in einer zentralen Relation halten würden sich viele Regeln vereinfachen und die Daten müssten nicht hin und her kopiert werden.
  \item Die Reihenfolge der Regelanwendung könnte man optimieren. Hier könnte man versuchen die Regeln einer Reihenfolge anzuwenden, um auf die Erzeugung von gewissen Fakten hinzuarbeiten oder man könnte versuchen Regeln so anzuwenden, das sie möglichst wenig neue Regeln auslösen bzw. ``leichtere'' Regeln bevorzugen.
  \item Beim Hinzufügen von neuen Axiomen könnte man diese gleich in eigene Deltas schreiben. Somit würde man das erneute Schlussfolgern beschleunigen, da nur mit den neuen Fakten gearbeitet werden muss.
  \item In den Ontologien werden IRIs zur Identifizierung verwendet. Man könnte hier den Speicherverbrauch reduzieren, in dem man die IRIs in einer gesonderten Relation ablegt, sie dort mit Ganzzahlen kodiert und ansonsten nur mit diesen Zahlen arbeitet.
  \item Gleiche strukturelle Ausdrücke könnten zusammengefasst werden, d.h. wenn zwei oder mehr komplexe Ausdrücke den selben Unterausdruck haben müsste dieser nur einmal abgespeichert werden, da er beim Schlussfolgern auch immer die selben Ergebnisse liefern würde. Das würde allerdings beim gezielten rückgängimachen von Änderungen zu Schwierigkeiten führen. Es könnte daher nicht für den kaskadierenden Löschmodus implementiert werden.
\end{itemize}