\chapter{Konzeption des Schlussfolgerer}

\begin{figure}[htb]
\begin{center}
	\scalebox{0.3}{
		\includegraphics{images/u2r3-konzeption.pdf}
  	}
  \caption{Das Konzept des u2r3 Reasoner}
  \label{image-konzept}
\end{center}
\end{figure}
TEXT

\input{mema-prinzip}

\section{Wissensrepräsentation in Zusammenhang mit einem Schlussfolgerer}

Die Formalismus einer Wissensrepräsentation hängt nicht direkt mit dem Kalkül zusammen, wenn man allerdings über die gewünschte Wissensrepräsentation bescheid weiß, ist es möglich den Schlussfolger daraufhin zu optimieren. Im Falle dieser Arbeit wird mit einer Wissensrepräsentation gearbeitet -- OWL2 RL -- und der Schlussfolgerer ist daraufhin optimiert, die in der Sprache repräsentierten Kriterien, wie Entscheidbarkeit und Komplexität zu erreichen.

Das bedeutet zum einen, das wenn die Sprache entscheidbar ist, also es einen terminierenden Alogrithmus gibt. Das ist durch zwei Dinge zu erreichen, ein gutes Design, welches diesen Algorithmus überhaupt ermöglicht und eine fehlerfreie Programmierung. Diese beiden Dinge sind natürlich nie so in der Praxis zu ereichen, aber es wurde versucht den Code und die Architektur so einfach und verständlich wie möglich zu halten, um Fehler schnell zu finden.

Die Komplexität einer Sprache gibt nur eine obere Schranke, den sog. \emph{worst-case} an, der für eine Lösungsfindung nötig ist. Die Umsetzung in einem Programm muss diesen dann erst noch erreichen. Das wird im hier behandelten Schlussfolgerer versucht zu erreichen, indem man sich nur auf eine Wissensrepräsentation konzentriert. Damit können die Regeln zur Wissensgewinnung nahe an der Definition der Sprache umgesetzt werden und somit auch nicht schlechter als die theoretischen Komplexität wird.
Die anderen Kriterien spielen für den Schlussfolgerer nur eine untergeordnete Rolle.

\input{aufbau-des-schlussfolgerers}

\input{arbeitsablauf-des-schlussfolgerers}

\section{Zurückziehen von Fakten}
Das Einfügen von Fakten, die man löschen will, um herauszufinden, welche gleich sind, um sie danach wieder zu löschen macht keinen großen Sinn. Erstens ist es Recht aufwendig zu implementieren. Zweitens müsste nach dem Einfügen neuer Fakten ersteinmal wieder die Ableitungsregeln ausgeführt werden. Das zerstört den Vorteil, den man sich durch forward-chaining mit direct-materialisation erkauft hat sofort wieder und bringt außerdem auch Nachteile mit sich wenn man noch nicht komplett fertig war mit dem Schlussfolgern.
Daher muss es ein Verfahren geben die zu löschenden Fakten zu finden ohne sie vorher einfügen zu müssen.
