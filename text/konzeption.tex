\chapter{Konzeption des Schlussfolgerer}

TEXT

\input{mema-prinzip}

\section{Wissensrepräsentation in Zusammenhang mit einem Schlussfolgerer}

Die Wissensrepräsentation hängt nicht direkt mit dem Schlussfolger zusammen, wenn man allerdings über die gewünschte Wissensrepräsentation bescheid weiß, ist es möglich den Schlussfolger daraufhin zu trimmen. Im Falle dieser Arbeit wird mit einer Wissensrepräsentation gearbeitet -- OWL2 RL -- und der Schlussfolgerer ist daraufhin optimiert, die in der Sprache repräsentierten Kriterien, wie Entscheidbarkeit und Komplexität zu erreichen.

Das bedeutet zum einen, das wenn die Sprache entscheidbar ist, also es immer einen terminierenden Alogrithmus gibt. Das ist durch zwei Dinge zu erreichen, ein gutes Design, welches diesen Algorithmus überhaupt ermöglicht und eine fehlerfreie Programmierung. Diese beiden Dinge sind natürlich nie so in der Praxis zu ereichen, aber es wurde versucht den Code und die Architektur so einfach und verständlich wie möglich zu halten, um Fehler schnell zu finden.

Die Komplexität einer Sprache gibt nur einen theoretischen Wert an, der für eine Lösungsfindung nötig ist. Die Umsetzung in einem Programm muss diesen dann erst noch erreichen. Das wird im hier behandelten Schlussfolgerer versucht zu erreichen, indem man sich nur auf eine Wissensrepräsentation konzentriert. Damit können die Regeln zur Wissensgewinnung nahe an der Definition der Sprache umgesetzt werden und somit auch nahe an der theoretischen Komplexität bleiben.
Die anderen Kriterien spielen für den Schlussfolgerer nur eine untergeordnete Rolle.

\input{arbeitsablauf-des-schlussfolgerers}

\input{aufbau-des-schlussfolgerers}

\section{Auswertungsstrategien}
Modusname: '''!EvaluationStrategy''' := COMMONLAST | RARELAST

== Alle Regeln nacheinander ==
trivial (nicht implementiert, sollte in der !RuleActionQueue umgesetzt werden)

== Abhängigkeiten der Regeln ausnutzen/Regeln in eine Queue packen ==

Regeln zusammenfassen, falls sie mehrmals angefragt werden

 * an ihrer Position in der Queue lassen
 * zurückschieben '''im Moment implementiert''' (siehe !RuleActionQueue)

== Regelauslösung ==
Für jeden Manipulation der Datenbank (DELETE/INSERT) wird/muss eine Reason ausgelöst (werden). Es wird dabei nur eine Reason ausgelöst, egal wieviele Zeilen von der Manipulation betroffen war. Eine Reason löst dann weitere Actions aus, je nachdem welche Regeln davon betroffen sind.


%{{{
DB Manipulation  (1) ===> (1) Reason (1) ===> (n) RuleActions
%}}}

%{{{
           Realtion                     Delta
%            ######
%            ######         <===           #
%            ######
                                          |
(welche Regel) |                          | (welche neuen Daten)
               |                          |
%                ####>  Reason  <==========

                          | (1)
                          |
                          | (eine Regel mit neuen Daten)
                          |
                          v (n)

                      RuleAction

%}}}

\input{komplexe-ausdruecke}

\begin{verbatim}
    * Was ist der Unterschied zu OWL1 DL/Lite?
    * Was sind Fähigkeiten, die der neue U2R2 haben soll?
          o Schlussfolgern, Konsistenzprüfung, Änderung, Löschung, OWLAPI Anbindung, Konformitätsüberprüfung auf OWL2 RL 
    * Wie konform und semantisch korrekt war U2R2?
    * Was ist der Unterschied in der Menge und Art der Regelimplementierung
          o Welche Techniken wurden verwendet
          o Wieviele wurden implementiert
                + Aussagekraft der Sprachen 
          o Wie komplex sind die implementierten Regeln? Wären alle Regeln aus u2r3 auch in u2r3 implementierbar gewesen, oder wie aufwändig wäre es gewesen diese zu implementieren?
                + Lohnt sich deshalb schon der Umstieg auf ein RDBMS? (einfachere Aufbau, standardisierte Funktionen, größere Funktionsumfang) 
    * Wie wird die Trennung von Klassen und Individuen im MEMA-Modell erhalten?
    
    
        * Welche Fragestellungen gibt es?
    * Wie hängen diese zusammen?
    * Wie können spätere Manipluationen durchgeführt werden?
    * Was ist der Aufwand nach einer Änderung (von Fakten oder Konzepten)?
    * Was ist die Ausdrucksmächtigkeit von OWL2 RL?
    * Was ist die Zeit und Speicher Komplexität von OWL2 RL?
    * Was ist der Unterschied zur Ausdrucksmächtigkeit von U2R2 (1)?
    * Welche Erkenntisse gibt es bereits?
    * Was sind die Fähigkeiten/Ausdrucksmächtigkeiten der verschiedenen Fragmente?
    * Was sind ihre Komplexitäten?
    * Was versteht man unter Truth-Maintenance? 


    * Wie muss dadurch über die entstandenen Daten geschloßen werden?
    * Was sind deduktive Datenbanken?
    * Können die SQL Statements generiert werden?
    * Wie bildet man Regeln allgemein auf SQL ab? RAP?
    * Kann man quadrat. Rekursion im auflösen?
    * Wie sieht das DB-Schema aus?
    * Kann man manche Ableitungsschritte zusammenfassen?
    * Was bringen rekursive Abfragen wirklich? (Es werden dadurch ja auch andere Regeln angestoßen und dann müssen die rekursiven wieder ran)
    * Wie wandelt man die Ontologie in INSERTs um? 
\end{verbatim}


\section{Zurückziehen von Fakten}
Das Einfügen von Fakten, die man löschen will um herauszufinden, welche gleich sind, um sie danach wieder zu löschen macht keinen großen Sinn. Erstens ist es Recht aufwendig zu implementieren. Zweitens müsste nach dem Einfügen neuer Fakten ersteinmal wieder die Ableitungsregeln ausgeführt werden. Das zerstört den Vorteil den man sich durch forward-chaining mit direct-materialisation erkauft hat sofort wieder und bringt außerdem auch Nachteille mit sich wenn man noch nicht komplett fertig war mit dem Schlussfolgern.
Daher muss es ein Verfahren geben die zu löschenden Fakten zu finden ohne sie vorher einfügen zu müssen.

\section{Finden von Fakten}
