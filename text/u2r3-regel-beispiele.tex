\subsection{Regelbeispiele}
In diesem Teil der Regelumsetzung wird an konkreten Beispielen gezeigt, wie eine Umsetzung der OWL2 RL Regeln in SQL möglich ist. Die SQL Abfragen benutzen dabei die vorher im MEMA-Prinzip erstellen Relationen

Die Abfragen werden zunächst allgemein an einfachen Regeln prinzipiell erklärt, danach wird auf die Sonderfälle eingegangen.

Insgesamt kann dabei in vier Kategorie unterschieden werden:
\begin{itemize}
  \item Gewöhnliche Regeln: Dabei werden verschiedene Fakten miteinander verknüpft, so das dabei neue Fakten entstehen können. Diese Regeln sind alle sehr schematisch umsetzbar.
  \item Listenregeln: Hier werden Listen von Fakten bearbeitet. Dabei ist nicht klar wie viele Elemente eine Liste enthält. Dies kann zu einem Problem werden, wenn man die Entstehungsgeschichte von Fakten, z.B. für das Löschen mitabspeichern will. Hier muss man gesondert darauf achten das diese Information der Entstehung nicht verloren geht.
  \item Inkonsistenzregeln: Sie sind ähnlich der neuen Regeln, erzeugen allerdings keine neuen Fakten. Falls sie neue Fakten erzeugen könnten bedeutet dies eine Inkonsistenz in der Ontologie.
  \item Regeln für Datentypen: Für typisierte Literal werden einige Überprüfung bzgl. der Gleichheit untereindander und der Konformität zu den in OWL2 RL eingebauten Datentypen durchgeführt.
  \item Einmalige Regeln: Einige Regeln haben keine Vorbedigung. Diese werden einmal zu Beginn der Regelanwendung ausgeführt.
\end{itemize}

\subsubsection{Einmalige Regeln}

cls-thing
if | then
true | owl:Thing rdf:type owl:Class

Diese Regel wird einmal zu Beginn in die Liste der Regelanwendungen gesteckt. Sie sorgt dafür das dieses Faktum eingefügt wird.

In SQL lautet dies:

INSERT INTO classAssertionEnt (entity, class)
	VALUES ('owl:Thing', 'owl:Class')

\subsubsection{Inkonsistenzregeln}
Inkonsistenzregeln erzeugen keine Fakten. Sie versuchen aber gewisse Fakten zu finden, die im Widerspruch zu einander stehen.

Die Inkonsistenzregeln cls-nothing2 sieht dabei so aus:

If | then
T(?x, rdf:type, owl:Nothing) | false

Dies wird in folgende SQL-Abfrage umgewandelt:

SELECT 1
FROM classAssertionEnt
WHERE class = 'owl:Nothing'

Die Relation classAssertionEnt ist die Relation, die die type-Beziehung speichert. Ist darin eine Zeile zu finden, die als type die KLasse owl:Nothing hat wird eine Zeile zurückgegeben. Falls also diese Abfrage eine oder mehrere Zeilen erzeugt liegt eine Inkonsistenz vor.

\subsubsection{Gewöhnliche Regeln}
Gewöhnliche Regeln erzeugen neue Fakten in der Datenbank. Eine einfache Regel ist hier eq-sym:

If | then
T(?x, owl:sameAS, ?y) | T(?y, owl:sameAS, ?x)

Dies wird wie folgt in SQL überführt:

INSERT INTO sameAs (left, right)
SELECT right, left
FROM sameAs

Wie die Abfrage zu Stande kommt sollte klar sein. Allerdings wurden in dieser Umwandlung schon einge Dinge vereinfacht, die in der Implementierung so nicht gemacht wurden.

\begin{enumerate}
  \item Was passiert wenn eine Zeile eingefügt werden soll, die schon enthalten ist?
  \item Wie würde man hier die Delta-Iteration einsetzen können, um nicht immer auf alle Fakten schließen zu müssen?
  \item Wie kann man die Entstehungsgeschiechte von neuen Fakten mitschreiben, um später effizientes Löschen zu ermöglichen.
\end{enumerate}

Diese Punkte werden jeweils in ihren speziellen Abgeschnitten. Um die Beispiel nicht untnötig komplizierter zu machen wird hier nicht näher darauf eingegangen.

Ein komplexeres Beispiel ist die Verknüpfung von Fakten um auf neue Fakten schließen zu können, z.B. in der Regel eq-rep-s:

If | then
T(?s1, owl:sameAs, ?s2), T(?s1, ?p, ?o) | T(?s2, ?p, ?o)

Die Verknüpfung wird durch einen JOIN auf die entsprechende Spalte realisiert.

\begin{lstlisting}[language=SQL]
INSERT INTO objectPropertyAssertion(subject, object, property)
SELECT sa.right, opa.property, opa.object
FROM objectPropertyAssertion AS opa
INNER JOIN sameAs AS sa
	ON sa.left = opa.subject
\end{lstlisting}

\subsubsection{Listenegeln}
Dabei können Listenregeln auch Regeln sein die neue Fakten erzeugen oder Inkonsistenzen überprüfen. Eine Inkonsistenzregel mit einer Liste ist z.B. prp-adp:

If | then
T(?x, rdf:type, owl:AllDisjointProperties)
T(?x, owl:members, ?y)
LIST[?y, ?p1, ..., ?pn]
T(?u, ?pi, ?v)
T(?u, ?pj, ?v)                                    | false | für alle 1 ≤ i < j ≤ n 

Bei der Erstellung der Abfrage kann man rein schematisch vorgehen. Es werden alle Relation auf den Variablen mit den gleichen Namen gejoint. Liefert dese Abfrage ein Ergebnis zurück ist eine Inkonsistenz vorhanden.

\begin{lstlisting}
SELECT 1
FROM classAssertionEnt AS ca
INNER JOIN members AS m ON ca.entity = m.class
INNER JOIN list AS l ON m.list = l.name
INNER JOIN objectPropertyAssertion AS opa1 ON opa1.property = l.property
INNER JOIN objectPropertyAssertion AS opa2 ON opa2.property = l.property
WHERE opa1.subject = opa2.subject AND opa1.object = opa2.object
	AND ca.class = 'owl:AllDisjointProperties'
\end{lstlisting}

Tatsächlich wird hier mehr gemacht als nötig ist. Die subject und object Spalten werden von beiden Seiten miteinander verglichen. Es wäre aber nur eine nötig. So ist es allerdings einfacher und natürlicher in SQL Syntax zu implementieren.

Im Falle der Regel eq-diff2 muss eine Tabelle doppelt importiert werden um wirkliche alle Fakten mit einander vergleichen zu können. Die ursprüngliche Regel.

If | then
T(?x, rdf:type, owl:AllDifferent)
T(?x, owl:members, ?y)
LIST[?y, ?z1, ..., ?zn]
T(?zi, owl:sameAs, ?zj) 	          | false 	| für alle 1 ≤ i < j ≤ n

Würde man hier streng nach Schema vorgehen würde die sameAs Relation nur einmal in der Abfrage auftauchen. Das würde allerdings nicht alle Kombinationen erzeugen. Die Abfrage ist damit sehr ähnlich der obigen und wird hier ausgespart.

Ein besonderer Typ der Listenregel ist z.B. cls-oo, diese Regel erzeugt mehrere Fakten. Das ist aber in der Umsetzung kein Problem.

If | then
T(?c, owl:oneOf, ?x)
LIST[?x, ?y1, ..., ?yn] 	 | T(?y1, rdf:type, ?c)
								...
								T(?yn, rdf:type, ?c) 

\subsubsection{Datentypenregeln}
Die Regeln zur Überprüfung der Datentypen ist nicht komplizierter, allerdings eine effiziente Umsetzung ist hier das Problem. Hier ist vor allem die dt-eq Regel das Problem.

If | then
true | T(lt1, owl:sameAs, lt2) | für alle Literale lt1 und lt2 mit dem selben Datenwert

Die aktuelle Umsetzung versucht sich möglichst nah an das MEMA-Prinzip und die Regel zu halten. Optimierungen sind hier noch wesentlich vorhanden.

\begin{lstlisting}
INSERT INTO sameAsLit (left, right)
SELECT ca1.literal, ca2.literal
FROM classAssertionLit AS ca1
CROSS JOIN classAssertionLit AS ca2
WHERE isSameLiteral(ca1.literal, ca2.literal)
\end{lstlisting}

Zum einen wird hier ein CROSS JOIN verwendet der eine der aufwendigsten Datenbankoperationen ist, außerdem können Literal nicht mit den üblichen Datenbankoperatoren verglichen werden. Hierzu wurde eine eigene Datenbankmethode geschrieben die dies übernimmt. DIe Datenbankmethde ruft eine Java-Routine auf die dann den eigentlichen Vergleich vornimmt. Diese beiden Verlangsamungen sind noch nicht genug. In der aktuellen IMplementierung sind nicht gleich alle Literal in der Relation, sondern können später noch hinzukommen, d.h. das diese Regel öfters aufgerufen werden kann. Hier ist also noch Potential für eine Optimierung vorhanden.


\subsubsection{Spezialfälle} 
In die Kategorie der Spezialfälle fallen drei Regeln aus OWL2 RL. Sie haben im Gegensatz zu den anderen Regeln eine variable Anzahl von Fakten in der Premise. Diese Fakten sind allerdings nur indirekt über eine Liste verknüpft.
 
Die erste Regel ist prp-spo2, sie erweitert eine Liste in eine Kette von Eigenschaften.

T(?p, owl:propertyChainAxiom, ?x)
LIST[?x, ?p1, ..., ?pn]
T(?u1, ?p1, ?u2)
T(?u2, ?p2 ?u3)
...
T(?un, ?pn, ?un+1) 	                      | T(?u1, ?p, ?un+1)

Die Kette muss dabei eine Start und ein Ende haben und die Glieder der Kette muss untereinander verbunden sein. ?u2 einmal als object und einmal als subject. Wenn das so ist ergeben der Start, die Eigenschaft und das Ende einen neuen Fakt.

Diese Regel ist in SQL in zwei Schritten übersetzt worden. Zunächst eine Hilfsabfrage die in der späteren Abfrage mehrmals verwendet wird.

\begin{lstlisting}
SELECT vopa.subject as vorgaenger,
       opa.subject  AS start,
       opa.object   AS ende,
       nopa.object  as nachfolger,
       l.name       AS lname,
       anzl.anz
FROM   list AS l
       INNER JOIN objectpropertyassertion AS opa
         ON opa.property = l.element
       INNER JOIN (SELECT   name,
                            COUNT(name) AS anz
                   FROM     list
                   GROUP BY name) AS anzl
         ON anzl.name = l.name
       LEFT OUTER JOIN objectpropertyassertion AS vopa
         ON vopa.object = opa.subject
       LEFT OUTER JOIN objectpropertyassertion AS nopa
         ON nopa.subject = opa.object
\end{lstlisting}

Diese Abfrage erzeugt ein Ergebnis in der alle objectPropertyAssertions einer Liste mit ihrem Vorgänger und Nachfolger aufgelistet sind. Außerdem wird die Anzahl der Elemente in der Liste mitgeführt.

\begin{lstlisting}
INSERT INTO objectPropertyAssertion
           (subject,
            property,
            object)
SELECT start.start,
       pc.property,
       ende.ende
FROM   (SELECT   lname,
                 anz
        FROM     (--- ...Unterabfrage für gültige Liste... ---)
        GROUP BY lname
        HAVING   COUNT(lname) = anz) AS thel
       INNER JOIN (SELECT lname,
                          start
                   FROM   (--- ...Unterabfrage für Vorgänger... ---)
                   WHERE  vorgaenger IS NULL) AS start
         ON start.lname = thel.lname
       INNER JOIN (SELECT lname,
                          ende
                   FROM   (--- ...Unterabfrage für Nachfolger... ---)
                   WHERE  nachfolger IS NULL) AS ende
         ON ende.lname = thel.lname
       INNER JOIN propertyChain AS pc
         ON pc.list = thel.lname
\end{lstlisting}

Die vorher beschriebene Abfrage wird mehrmals eingesetzt. Sie erzeugt einerseits nur gültige Liste. Das ist die erste Abfrage. Die zweite Unterabfrage wählt das Startelement aus und die dritte das Endeelement. Am Ende wird es noch auf die eigentliche propertyChain gejoined.

Die zweite Regel überprüft, ob ein Invidivum in allen Teilen einer Schnittmenge vorhanden ist. Falls ja wird es der Klasse dieser Schnittmenge hinzugefügt.

If | then
T(?c, owl:intersectionOf, ?x)
LIST[?x, ?c1, ..., ?cn]
T(?y, rdf:type, ?c1)
T(?y, rdf:type, ?c2)
...
T(?y, rdf:type, ?cn) 	             | T(?y, rdf:type, ?c) 	 

\begin{lstlisting}
INSERT INTO classAssertionEnt
           (entity,
            class)
SELECT   clsA.entity AS entity,
         int.class   AS class
FROM     (SELECT   name,
                   COUNT(name) AS anzahl
          FROM     list
          GROUP BY name) AS anzl
         INNER JOIN list AS l
           ON anzl.name = l.name
         INNER JOIN classAssertionEnt AS clsA
           ON l.element = clsA.class
         INNER JOIN intersectionOf AS int
           ON int.list = l.name
GROUP BY l.name,
         clsA.entity,
         int.class
HAVING   COUNT(l.name) = anzl.anzahl
\end{lstlisting}

Diese Abfrage wurd auch wesentlich vereinfacht. Für die Abspeicherung einer Historie dürfen die Fakten erst danach gruppiert werden, dann wäre allerdings keine Überprüfung mit HAVING möglich.

Die aktuelle Umsetzung kann im Wiki oder im Code gefunden werden.

Die dritte Abfrage prp-key überprüft ob zwei Individuen das Gleiche sind. Dies geschieht an Hand einer Liste  von Key-Eigenschaften, wenn diese übereinstimmen sind auch die die Individuen gleich.

If | then
T(?c, owl:hasKey, ?u)
LIST[?u, ?p1, ..., ?pn]
T(?x, rdf:type, ?c)
T(?x, ?p1, ?z1)
...
T(?x, ?pn, ?zn)
T(?y, rdf:type, ?c)
T(?y, ?p1, ?z1)
...
T(?y, ?pn, ?zn) 	                 | T(?x, owl:sameAs, ?y)

Die Abfrage ist der Einfachheit ebenfalls in zwei Teile zerlegt. Die Unterabfrage die mehrmals verwendet wird erzeugt zunächst eine gültige Liste von Individuen die über eine Eigenschaft mit dem gleichen Objekt verbunden sind.
\begin{lstlisting}
SELECT pax.subject, sl.name, anzl.anz
FROM list AS sl
        INNER JOIN (
                SELECT name, COUNT(name) AS anz
                FROM list
                GROUP BY name
        ) AS anzl
                ON anzl.name = sl.name
        INNER JOIN (
                SELECT id, subject, property, object
                FROM objectPropertyAssertion
                UNION
                SELECT id, subject, property, object
                FROM dataPropertyAssertion
        ) AS pax
                ON sl.element = pax.property
        INNER JOIN (
                SELECT id, subject, property, object
                FROM objectPropertyAssertion
                UNION
                SELECT id, subject, property, object
                FROM dataPropertyAssertion
        ) AS pay
                ON sl.element = pay.property AND pax.property = pay.property AND pax.object = pay.object
GROUP BY pax.subject, sl.name
--- Es werden alle Listenelemente doppelt erzeugt
HAVING COUNT(sl.name) = 2*anz
\end{lstlisting}

Diese Liste wird dann in der folgenden Abfrage zweimal verwendet um zwei Individuen miteinander verleichen zu können.
\begin{lstlisting}
INSERT INTO sameAsEnt (left, right)
SELECT ca1.entity AS left, ca2.entity AS right
FROM hasKey AS hk
     INNER JOIN list AS l
             ON l.name = hk.list
     INNER JOIN classAssertionEnt AS ca1
            ON ca1.class = hk.class
     INNER JOIN classAssertionEnt AS ca2
            ON ca2.class = hk.class
     INNER JOIN (--- ...Unterabfrage... ---) AS valid1
                ON valid1.subject = ca1.entity
     INNER JOIN (--- ...Unterabfrage... ---) AS valid2
                ON valid2.subject = ca2.entity
\end{lstlisting}