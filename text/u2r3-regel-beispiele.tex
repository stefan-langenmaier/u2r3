\subsection{Regelbeispiele}
In diesem Teil der Regelumsetzung wird an konkreten Beispielen gezeigt, wie eine Umsetzung der OWL2 RL Regeln in SQL möglich ist. Die SQL Abfragen benutzen dabei die vorher im MEMA-Prinzip erstellen Relationen

Die Abfragen werden zunächst allgemein an einfachen Regeln prinzipiell erklärt, danach wird auf die Sonderfälle eingegangen.

Insgesamt kann dabei in vier Kategorie unterschieden werden:
\begin{itemize}
  \item Gewöhnliche Regeln: Dabei werden verschiedene Fakten miteinander verknüpft, so das dabei neue Fakten entstehen können. Diese Regeln sind alle sehr schematisch umsetzbar.
  \item Listenregeln: Hier werden Listen von Fakten bearbeitet. Dabei ist nicht klar wie viele Elemente eine Liste enthält. Dies kann zu einem Problem werden, wenn man die Entstehungsgeschichte von Fakten, z.B. für das Löschen mitabspeichern will. Hier muss man gesondert darauf achten das diese Information der Entstehung nicht verloren geht.
  \item Inkonsistenzregeln: Sie sind ähnlich der neuen Regeln, erzeugen allerdings keine neuen Fakten. Falls sie neue Fakten erzeugen könnten bedeutet dies eine Inkonsistenz in der Ontologie.
  \item Regeln für Datentypen: Für typisierte Literal werden einige Überprüfung bzgl. der Gleichheit untereindander und der Konformität zu den in OWL2 RL eingebauten Datentypen durchgeführt.
  \item Einmalige Regeln: Einige Regeln haben keine Vorbedigung. Diese werden einmal zu Beginn der Regelanwendung ausgeführt.
\end{itemize}

\subsubsection{Einmalige Regeln}

cls-thing
if | then
true | owl:Thing rdf:type owl:Class

Diese Regel wird einmal zu Beginn in die Liste der Regelanwendungen gesteckt. Sie sorgt dafür das dieses Faktum eingefügt wird.

In SQL lautet dies:

INSERT INTO classAssertionEnt (entity, class)
	VALUES ('owl:Thing', 'owl:Class')

\subsubsection{Inkonsistenzregeln}
Inkonsistenzregeln erzeugen keine Fakten. Sie versuchen aber gewisse Fakten zu finden, die im Widerspruch zu einander stehen.

Die Inkonsistenzregeln cls-nothing2 sieht dabei so aus:

If | then
T(?x, rdf:type, owl:Nothing) | false

Dies wird in folgende SQL-Abfrage umgewandelt:

SELECT 1
FROM classAssertionEnt
WHERE class = 'owl:Nothing'

Die Relation classAssertionEnt ist die Relation, die die type-Beziehung speichert. Ist darin eine Zeile zu finden, die als type die KLasse owl:Nothing hat wird eine Zeile zurückgegeben. Falls also diese Abfrage eine oder mehrere Zeilen erzeugt liegt eine Inkonsistenz vor.

\subsubsection{Gewöhnliche Regeln}
Gewöhnliche Regeln erzeugen neue Fakten in der Datenbank. Eine einfache Regel ist hier eq-sym:

If | then
T(?x, owl:sameAS, ?y) | T(?y, owl:sameAS, ?x)

Dies wird wie folgt in SQL überführt:

INSERT INTO sameAs (left, right)
SELECT right, left
FROM sameAs

Wie die Abfrage zu Stande kommt sollte klar sein. Allerdings wurden in dieser Umwandlung schon einge Dinge vereinfacht, die in der Implementierung so nicht gemacht wurden.

\begin{enumerate}
  \item Was passiert wenn eine Zeile eingefügt werden soll, die schon enthalten ist?
  \item Wie würde man hier die Delta-Iteration einsetzen können, um nicht immer auf alle Fakten schließen zu müssen?
  \item Wie kann man die Entstehungsgeschiechte von neuen Fakten mitschreiben, um später effizientes Löschen zu ermöglichen.
\end{enumerate}

Diese Punkte werden jeweils in ihren speziellen Abgeschnitten. Um die Beispiel nicht untnötig komplizierter zu machen wird hier nicht näher darauf eingegangen.

Ein komplexeres Beispiel ist die Verknüpfung von Fakten um auf neue Fakten schließen zu können, z.B. in der Regel eq-rep-s:

If | then
T(?s1, owl:sameAs, ?s2), T(?s1, ?p, ?o) | T(?s2, ?p, ?o)

Die Verknüpfung wird durch einen JOIN auf die entsprechende Spalte realisiert.

\begin{lstlisting}[language=SQL]
INSERT INTO objectPropertyAssertion(subject, object, property)
SELECT sa.right, opa.property, opa.object
FROM objectPropertyAssertion AS opa
INNER JOIN sameAs AS sa
	ON sa.left = opa.subject
\end{lstlisting}

\subsubsection{Listenegeln}
Dabei können Listenregeln auch Regeln sein die neue Fakten erzeugen oder Inkonsistenzen überprüfen. Eine Inkonsistenzregel mit einer Liste ist z.B. prp-adp:

If | then
T(?x, rdf:type, owl:AllDisjointProperties)
T(?x, owl:members, ?y)
LIST[?y, ?p1, ..., ?pn]
T(?u, ?pi, ?v)
T(?u, ?pj, ?v)                                    | false | für alle 1 ≤ i < j ≤ n 

Bei der Erstellung der Abfrage kann man rein schematisch vorgehen. Es werden alle Relation auf den Variablen mit den gleichen Namen gejoint. Liefert dese Abfrage ein Ergebnis zurück ist eine Inkonsistenz vorhanden.

\begin{lstlisting}
SELECT 1
FROM classAssertionEnt AS ca
INNER JOIN members AS m ON ca.entity = m.class
INNER JOIN list AS l ON m.list = l.name
INNER JOIN objectPropertyAssertion AS opa1 ON opa1.property = l.property
INNER JOIN objectPropertyAssertion AS opa2 ON opa2.property = l.property
WHERE opa1.subject = opa2.subject AND opa1.object = opa2.object
	AND ca.class = 'owl:AllDisjointProperties'
\end{lstlisting}

Tatsächlich wird hier mehr gemacht als nötig ist. Die subject und object Spalten werden von beiden Seiten miteinander verglichen. Es wäre aber nur eine nötig. So ist es allerdings einfacher und natürlicher in SQL Syntax zu implementieren.

Im Falle der Regel eq-diff2 muss eine Tabelle doppelt importiert werden um wirkliche alle Fakten mit einander vergleichen zu können. Die ursprüngliche Regel.

If | then
T(?x, rdf:type, owl:AllDifferent)
T(?x, owl:members, ?y)
LIST[?y, ?z1, ..., ?zn]
T(?zi, owl:sameAs, ?zj) 	          | false 	| für alle 1 ≤ i < j ≤ n

Würde man hier streng nach Schema vorgehen würde die sameAs Relation nur einmal in der Abfrage auftauchen. Das würde allerdings nicht alle Kombinationen erzeugen. Die Abfrage ist damit sehr ähnlich der obigen und wird hier ausgespart.

Ein besonderer Typ der Listenregel ist z.B. cls-oo, diese Regel erzeugt mehrere Fakten. Das ist aber in der Umsetzung kein Problem.

If | then
T(?c, owl:oneOf, ?x)
LIST[?x, ?y1, ..., ?yn] 	 | T(?y1, rdf:type, ?c)
								...
								T(?yn, rdf:type, ?c) 

\subsubsection{Datentypenregeln}
Die Regeln zur Überprüfung der Datentypen ist nicht komplizierter, allerdings eine effiziente Umsetzung ist hier das Problem. Hier ist vor allem die dt-eq Regel das Problem.

If | then
true | T(lt1, owl:sameAs, lt2) | für alle Literale lt1 und lt2 mit dem selben Datenwert

Die aktuelle Umsetzung versucht sich möglichst nah an das MEMA-Prinzip und die Regel zu halten. Optimierungen sind hier noch wesentlich vorhanden.

\begin{lstlisting}
INSERT INTO sameAsLit (left, right)
SELECT ca1.literal, ca2.literal
FROM classAssertionLit AS ca1
CROSS JOIN classAssertionLit AS ca2
WHERE isSameLiteral(ca1.literal, ca2.literal)
\end{lstlisting}

Zum einen wird hier ein CROSS JOIN verwendet der eine der aufwendigsten Datenbankoperationen ist, außerdem können Literal nicht mit den üblichen Datenbankoperatoren verglichen werden. Hierzu wurde eine eigene Datenbankmethode geschrieben die dies übernimmt. DIe Datenbankmethde ruft eine Java-Routine auf die dann den eigentlichen Vergleich vornimmt. Diese beiden Verlangsamungen sind noch nicht genug. In der aktuellen IMplementierung sind nicht gleich alle Literal in der Relation, sondern können später noch hinzukommen, d.h. das diese Regel öfters aufgerufen werden kann. Hier ist also noch Potential für eine Optimierung vorhanden.


\subsubsection{Spezialfälle} 
 