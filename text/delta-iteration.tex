\section{delta-Iteration}

Unabhängig von der Art der delta-Iteratoin muss immer der Ausführungskontext bekannt sein, d.h. welche delta-Iteration ist aktiv, auf welches delta wird gearbeitet. Ein delta muss dabei die Information enthalten auf welcher Relation es arbeitet und auf welche Teil.

Zum Ausführungskontext gehört je nach Modus auch noch die Information, ob die Regel schon auf das Ziel delta angewendet wurde.



Die delta-Iteration ist ein Verfahren, um bei Regelanwendungen, die Datenmenge so zu reduzieren, das nur solche enthalten sind die noch nicht berücksichtigt wurden und somit die tatsächlich zu betrachtenden Menge zu reduzieren.

Mir sind im folgenden zwei Varianten der delta-Iteration klarer geworden. Diese tragen im folgenden die Namen immediate delta-Iteration und collective delta-Iteration. Timo Weithöhner hat in seiner Implementierung die collective delta-Iteration verwendet.

Modusname: DeltaIteration := COLLECTIVE | IMMEDIATE
immediate delta-Iteration

Hierbei erzeugt jede Regelanwendung sofort ihr eigenes Delta, mit dem weitergearbeitet werden kann.

Wenn Zeilen erzeugt wurden, wird sofort das dazugehörige Delta erzeugt und dafür alle notwendigen Regelanwendungen ausgelöst.

Regel: sameas-eq-ref-s //neue Fakten
=> delta sameas
   => new Reason(sameas, delta)
      => new RuleAction(rule1, delta)
         new RuleAction(rule2, delta)
         ...

Ruleprocessor:

while(action = list.popAction()) \{
  action.rule.apply(action.delta)
  if (!(list.contains(delta)) //kann überprüft werden, da alle Regel die dieses Delta benötigen könnten sofort erzeugt werden
    delta.addToRelation()
    delta.drop()
    delta == null
  \}
\}

Vorteile:

Kann besser parallelisiert werden, da soviele Actions wie möglich gleizeitig angewand werden können. (Delta Entfernung muss noch abgesichert werden. nicht wie oben dargestellt.)

Nachteile:

Es entstehen viele Deltas gleichzeitg. Deltas enthalten unter Umständen nur wenig Inhalt. (Muss nicht zwangsläufig schlecht sein, aber nicht unbedingt klar wie sich das auf ein DBMS auswirkt.)
collective delta-Iteration ¶

Vom aktuellen Stand einer Relation werden erst einmal alle Önderungen in einer Hilfsrelation gesammelt. Sind alle abgearbeitet, wird das Delta erstellt und die nächste Phase beginnt.

Wenn Zeilen erzeugt werden, dann kommen diese ersteinmal in eine Hilfsrelation, bis alle Rgeln, die sich diese Relation berufen abgearbeitet sind. Dann wird das Delta erzeugt und hinzugefügt.

Regel: sameas-eq-ref-s //neue Fakten
=> aux sameas

do \{
  while (action = list.popAction()) \{
    action.rule.apply(action.delta);
    //if nicht möglich, da man ja nicht weiß, ob noch eine Regel entsteht (vllt schon möglich aber äußerst aufwendig)
  \}
\}
while (applyRelations()); //WAIT hier muss immer alles zusammenlaufen, jetzt können keine Regeln angewendet werden

applyRelations() \{
  for(r : relations)
    r.applyAux();
\}

applyAux() {
  createDelta;
  addDelta();
  clearAux();
  new Reason(relation, delta);
}

Vorteile:

    * Es gibt immer nur eine Hilfsrelation und ein Delta, also eine fixe Anzahl an Tabellen.
    * Es werden evtl. größere Menge an neuen Fakten zusammengefasst. (Muss nicht notwendiger weise gut sein.) 

Nachteile:

Eine Parallelsierung kann nicht vollständig durchgeführt werden, da zu gewissen Zeitpunkten, die Regelanwendung unterbrochen wird.
Simulation ¶

Die collective delta-Iteration kann mit der immediate simuliert werden. Dabei lösen die Regeln nicht sofort neue Reasons aus, sondern das passiert erst, wenn die neuen Daten übernommen werden. Neue Daten werden erst nach dem abarbeiten aller Regeln übernommen. Die Hilfstabelle ist dabei das neue Delta, die Delta-Tabelle ist das Delta auf dem auch bei der immediate gearbeitet wird. Es muss dabei darauf geachtet werden, das in das neue delta nur echte neue Fakten kommen bzw. beim eintragen in die gesammte Tabelle die nicht neuen herausgelöscht werden (besser)

Unterscheidungen müssen also an folgenden Stellen getroffen werden:

    * classify(): nach abarbeiten aller Regeln müssen alle Relationen die angefasst wurden noch hinzugefügt werden und evtl. ein weiterer Lauf stattfinden, falls es eine Relation gab.
    * apply(): das erzeugen des Deltas brauch eine andere Abfrage, da evtl in das selbe delta aka AUX mehrmals geschrieben werden kann
    * apply(): das hinzufügen neuer Fakten darf nur im immediate Fall passieren.
    * makeDirty()/isDirty(): eine Relation muss wissen, ob sie noch ausstehende Operationen hat
    * merge(): die Relation kann jetzt das alte Delta löschen 

