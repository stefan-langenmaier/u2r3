\section{delta-Iteration}
\label{abschnitt-delta-iteration}

Unabhängig von der Art der delta-Iteration muss immer der Ausführungskontext bekannt sein, d.h. welche delta-Iteration ist aktiv, auf welches delta wird gearbeitet. Ein delta muss dabei die Information enthalten auf welcher Relation es arbeitet und auf welchen Teil.

Zum Ausführungskontext gehört je nach Modus auch noch die Information, ob die Regel schon auf das Ziel delta angewendet wurde.

Die delta-Iteration ist ein Verfahren, um bei Regelanwendungen, die Datenmenge so zu reduzieren, das nur solche enthalten sind, die noch nicht berücksichtigt wurden und somit die tatsächlich zu betrachtenden Menge zu reduzieren.

Während der ersten Entwicklung sind dabei zwei Varianten der delta-Iteration klar geworden. Diese tragen im folgenden die Namen \emph{immediate} delta-Iteration und \emph{collective} delta-Iteration. Timo Weithöhner hat in seiner Implementierung die collective delta-Iteration verwendet.

\subsection{immediate delta-Iteration}

Hierbei erzeugt jede Regelanwendung sofort ihr eigenes Delta, mit dem weitergearbeitet werden kann.

Wenn Zeilen erzeugt wurden, wird sofort das dazugehörige Delta erzeugt und dafür alle notwendigen Regelanwendungen ausgelöst.

Im folgenden ist ein Beispiel gegeben, wie der Ablauf bei der Anwendung einer Regel ist die neue Fakten erzeugt hat und wie diese dann verarbeitet wird.

Angenommen die Regel eq-ref-s erzeugt neue Fakten, diese landen in einem delta der sameas Relation. Das löst eine ``Reason'' aus mit der Information welches delta neue Fakten enthalten hat. Wenn der Regelprozessor diese erhält erzeugt er für diese Kombination sog. RuleActions, d.h. er bringt alle Regeln die auf diesem delta arbeiten in eine Warteschlange. Zu jeder Regel speichert er den Ausführungskontext, auf den sie angewendet werden soll mit ab. Die RuleActions warten dann bis sie zur Ausführung gebracht werden.

\begin{verbatim}
Regel: eq-ref-s //neue Fakten
=> delta sameas
   => new Reason(sameas, delta)
      => new RuleAction(rule1, delta)
         new RuleAction(rule2, delta)
         ...
\end{verbatim}

Der RuleProcessor ist dann auch verantwortlich die Ausführung der RuleActions zu starten. Das passiert in einer Schleife, die die Elemente der Warteschlange abarbeitet bis keine weiteren Elemente vorhanden sind.

Dies ist im folgenden Code \ref{code-immediate-delta-iteration} schematisch dargestellt:

\begin{figure}[htp]
	\caption{Abarbeitung der RuleActions im immediate Modus.}
	\label{code-immediate-delta-iteration}
	\begin{lstlisting}[language=Java]
while(action = rulesToApply.popAction()) {
	action.rule.apply(action.delta);
	
	if (!(rulesToApply.contains(delta)) {
		delta.addToRelation();
		delta.drop();
		delta == null;
	}
}
	\end{lstlisting}
\end{figure}


Der Vorteil dieser Vorgehensweise ist das es besser parallelisiert werden kann, da soviele Actions wie möglich gleizeitig angewand werden können. Die Parallelisierung ist eines der Ziele die eventuell in der Zukunft umgesetzt werden sollen.

Der Nachteil ist das viele Deltas gleichzeitg entstehen und insgesamt mehr Regel angewendet werden müssen. Die deltas enthalten unter Umständen nur wenig Inhalt, d.h. die Abfragen arbeiten auf kleineren Datenmenge aber eine Datenbanksystem lohnt sich eventuell erst wirklich bei großen Datenmengen. Es muss nicht zwangsläufig schlecht sein, aber es istnicht unbedingt klar wie sich das auf ein DBMS auswirkt.

\subsection{collective delta-Iteration}

Vom aktuellen Stand einer Relation werden erst einmal alle Änderungen in einer Hilfsrelation gesammelt. Sind alle abgearbeitet, wird das Delta erstellt und die nächste Phase beginnt.

Wenn Zeilen erzeugt werden, dann kommen diese ersteinmal in eine Hilfsrelation, bis alle Rgeln, die sich diese Relation berufen abgearbeitet sind. Dann wird das Delta erzeugt und hinzugefügt.

\begin{verbatim}
Regel: sameas-eq-ref-s //neue Fakten
=> aux sameas
\end{verbatim}

\begin{figure}[htp]
	\caption{Abarbeitung der RuleActions im immediate Modus.}
	\label{code-immediate-delta-iteration}
	\begin{lstlisting}[language=Java]
do {
  while (action = list.popAction()) {
    action.rule.apply(action.delta);
  }
}
while (applyRelations()); //WAIT

boolean applyRelations() {
  for(r : relations)
    r.applyAux();
  return relations.wereDirty()
}

applyAux() {
  createDelta;
  addDelta();
  clearAux();
  new Reason(relation, delta);
}
	\end{lstlisting}
\end{figure}

Vorteile:
\begin{itemize}
  \item Es gibt immer nur eine Hilfsrelation und ein Delta, also eine fixe Anzahl an Tabellen.
  \item Es werden evtl. größere Menge an neuen Fakten zusammengefasst. (Muss nicht notwendiger weise gut sein.)
\end{itemize}

Ein Nachteil ist, das die Parallelsierung nicht vollständig durchgeführt werden kann, da zu gewissen Zeitpunkten (Zeile 6), die Regelanwendung unterbrochen wird und die Ausführung wieder synchronisiert werden muss.

\subsection{Simulation}

Die collective delta-Iteration kann mit der immediate simuliert werden. Dabei lösen die Regeln nicht sofort neue Reasons aus, sondern das passiert erst, wenn die neuen Daten übernommen werden. Neue Daten werden erst nach dem abarbeiten aller Regeln übernommen. Die Hilfstabelle ist dabei das neue Delta, die Delta-Tabelle ist das Delta auf dem auch bei der immediate gearbeitet wird. Es muss dabei darauf geachtet werden, das in das neue delta nur echte neue Fakten kommen bzw. beim eintragen in die gesammte Tabelle die nicht neuen herausgelöscht werden (besser)

Unterscheidungen müssen also an folgenden Stellen getroffen werden:
\begin{itemize}
  \item classify(): nach abarbeiten aller Regeln müssen alle Relationen die angefasst wurden noch hinzugefügt werden und evtl. ein weiterer Lauf stattfinden, falls es eine Relation gab.
  \item apply(): das erzeugen des Deltas brauch eine andere Abfrage, da evtl in das selbe delta aka AUX mehrmals geschrieben werden kann
  \item apply(): das hinzufügen neuer Fakten darf nur im immediate Fall passieren.
  \item makeDirty()/isDirty(): eine Relation muss wissen, ob sie noch ausstehende Daten, die zu mergen sind hat.
  \item merge(): die Relation kann jetzt das alte Delta löschen 
\end{itemize}

Die Implementierung des u2r3 unterstützt beide Varianten der delta-Iteration. Diese können in der Konfigurationsdatei mit der Option DeltaIteration verändert werden. Gültige Werte sind \emph{COLLECTIVE} oder \emph{IMMEDIATE}.
